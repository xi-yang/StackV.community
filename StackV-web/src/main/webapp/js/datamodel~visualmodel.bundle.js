(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["datamodel~visualmodel"],{

/***/ "./src/main/webapp/visual/data-model/consts.js":
/*!*****************************************************!*\
  !*** ./src/main/webapp/visual/data-model/consts.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EXPAND_KEYS = exports.HULL_OFFSET = exports.HULL_CURVE = exports.DEFAULT_COLLISION_RADIUS = exports.D3_GRAPHIC_KEYS = exports.RECURSION_BLACK_LIST_KEY_NAME_LIST = void 0;\n\nvar d3 = _interopRequireWildcard(__webpack_require__(/*! d3 */ \"./node_modules/d3/index.js\"));\n\n/**\n * Black list key name to prevent back-refer to parent when calling recursively\n *\n * @type {Array<string>}\n */\nvar RECURSION_BLACK_LIST_KEY_NAME_LIST = ['id', 'type', 'value', 'labeltype', 'encoding', 'belongsTo', 'providedByService', 'aggregateChildren', 'parentList', 'directParentList', 'isPortOf'];\n/**\n * For local persistent purpose\n *\n * @type {Array<string>}\n */\n\nexports.RECURSION_BLACK_LIST_KEY_NAME_LIST = RECURSION_BLACK_LIST_KEY_NAME_LIST;\nvar D3_GRAPHIC_KEYS = ['x', 'y', 'dx', 'dy', 'vx', 'vy', 'fx', 'fy', 'index'];\n/**\n * The default collision radius (graphic)\n *\n * @type {number}\n */\n\nexports.D3_GRAPHIC_KEYS = D3_GRAPHIC_KEYS;\nvar DEFAULT_COLLISION_RADIUS = 30;\n/**\n * D3 function to generate a smooth path for hull}\n * @type {Function|*}\n */\n\nexports.DEFAULT_COLLISION_RADIUS = DEFAULT_COLLISION_RADIUS;\nvar HULL_CURVE = d3.line().curve(d3.curveCatmullRomClosed);\n/**\n * Distance to the edge of hull\n *\n * @type {number}\n */\n\nexports.HULL_CURVE = HULL_CURVE;\nvar HULL_OFFSET = 35;\n/**\n * Will only expand these sub-keys\n * @type {Array<string>}\n */\n// const EXPAND_KEYS = ['hasNode', 'hasTopology', 'hasBidirectionalPort'];\n\nexports.HULL_OFFSET = HULL_OFFSET;\nvar EXPAND_KEYS = ['hasNode', 'hasTopology'];\nexports.EXPAND_KEYS = EXPAND_KEYS;\n\n//# sourceURL=webpack:///./src/main/webapp/visual/data-model/consts.js?");

/***/ }),

/***/ "./src/main/webapp/visual/data-model/data-model.js":
/*!*********************************************************!*\
  !*** ./src/main/webapp/visual/data-model/data-model.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _toConsumableArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ \"./node_modules/@babel/runtime/helpers/toConsumableArray.js\"));\n\nvar _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/typeof.js\"));\n\nvar _keys = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/core-js/object/keys */ \"./node_modules/@babel/runtime/core-js/object/keys.js\"));\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\"));\n\nvar _lodash = _interopRequireDefault(__webpack_require__(/*! lodash */ \"./node_modules/lodash/lodash.js\"));\n\nvar Utils = _interopRequireWildcard(__webpack_require__(/*! ./utils */ \"./src/main/webapp/visual/data-model/utils.js\"));\n\nvar _serverData = _interopRequireDefault(__webpack_require__(/*! ./server-data/server-data */ \"./src/main/webapp/visual/data-model/server-data/server-data.js\"));\n\nvar _versionControl = _interopRequireDefault(__webpack_require__(/*! ./version-control/version-control */ \"./src/main/webapp/visual/data-model/version-control/version-control.js\"));\n\nvar Constants = _interopRequireWildcard(__webpack_require__(/*! ./consts */ \"./src/main/webapp/visual/data-model/consts.js\"));\n\n/**\n * Front-end Data Model engine, provide API for further D3 rendering\n */\nvar DataModel =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Local data field\n   * @type {object}\n   */\n\n  /**\n   * Current nodes in view hierarchy\n   * @type {Array<object>}\n   */\n\n  /**\n   * Current available nodes\n   * @type {Array<object>}\n   */\n\n  /**\n   * Current background Convex Hulls Data\n   * @type {Array<object>}\n   */\n\n  /**\n   * Record the current expansion status\n   * @type {object}\n   */\n\n  /**\n   * Version controller\n   * @type {VersionControl}\n   */\n\n  /**\n   * Start a new DataModel instance\n   *\n   * @param {object} initialServerData - An object contains all Node Info\n   */\n  function DataModel(initialServerData) {\n    (0, _classCallCheck2.default)(this, DataModel);\n    (0, _defineProperty2.default)(this, \"data\", {});\n    (0, _defineProperty2.default)(this, \"nodes\", []);\n    (0, _defineProperty2.default)(this, \"links\", []);\n    (0, _defineProperty2.default)(this, \"hulls\", []);\n    (0, _defineProperty2.default)(this, \"expandInfo\", {});\n    (0, _defineProperty2.default)(this, \"versionControl\", new _versionControl.default());\n    // Ensure context\n    this.nodeFetcher = this.nodeFetcher.bind(this); // The procedure of initialization is actually a PATCH_UPDATE to Empty Data\n\n    this.update(initialServerData, true);\n  }\n  /**\n   * Provide new data\n   * @param {object} latestServerData - latest server raw data\n   * @param {boolean} initial - Initial data\n   * @returns {Array<string>} List of removed node id\n   */\n\n\n  (0, _createClass2.default)(DataModel, [{\n    key: \"update\",\n    value: function update(latestServerData) {\n      var _this = this;\n\n      var initial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      var parsedLatestResult = _serverData.default.parse(latestServerData);\n\n      var changed = true;\n      var removedIdList = []; // speed up initialization process\n\n      if (!initial) {\n        var diffData = this.versionControl.diff(parsedLatestResult);\n        changed = diffData.changed;\n        removedIdList = diffData.remove;\n      }\n\n      var newNodeIdList = [];\n\n      if (changed) {\n        // save version\n        this.versionControl.updateVersion(parsedLatestResult); // get NEW expand IDs\n\n        var latestExpandedKeys = (0, _keys.default)(this.expandInfo).filter(function (d) {\n          return removedIdList.indexOf(d) === -1;\n        }); // update node data\n\n        for (var nodeId in parsedLatestResult.serverData) {\n          var nodeData = parsedLatestResult.serverData[nodeId];\n\n          if (this.data.hasOwnProperty(nodeId)) {\n            // updating a EXIST node\n            _lodash.default.assign(this.data[nodeId].metadata, nodeData.metadata);\n          } else {\n            this.data[nodeId] = nodeData;\n            newNodeIdList.push(nodeId);\n          }\n        } // remove deleted node\n\n\n        if (removedIdList.length > 0) {\n          removedIdList.forEach(function (nodeId) {\n            delete _this.data[nodeId];\n            delete parsedLatestResult.topLevel[nodeId];\n          });\n        } // Calculate and assign Top-Level nodes\n\n\n        this.nodes = Utils.prepareData(this.data, parsedLatestResult.topLevel, this.nodeFetcher); // calculate influenced EXPANDED NODES\n\n        for (var _nodeId in this.expandInfo) {\n          if (this.expandInfo.hasOwnProperty(_nodeId)) {\n            /**\n             * Check if the children node of current expanded node\n             * INCLUDE NEW NODEs\n             * or SOME NODEs INSIDE it was being REMOVED\n             *\n             * If this happens, REMOVE ALL layout data of that PARENT NODE\n             * In case the force layout is being MESSED UP after RE-RENDERING\n             */\n            var _nodeData = this.nodeFetcher(_nodeId);\n\n            if (_nodeData) {\n              var currentChildrenNodeIdList = this.expandInfo[_nodeId].nodes.map(function (d) {\n                return d.id;\n              });\n\n              var latestChildrenNodeIdList = [];\n\n              if (this.canExpand(_nodeData)) {\n                latestChildrenNodeIdList = this.childrenElementIdList(_nodeData);\n              } // Check if NEW NODE joined\n\n\n              var _newNodeIdList = _lodash.default.difference(latestChildrenNodeIdList, currentChildrenNodeIdList); // Check if OLD NODE removed\n\n\n              var removedNodeIdList = _lodash.default.difference(currentChildrenNodeIdList, latestChildrenNodeIdList);\n\n              if (_newNodeIdList.length > 0 || removedNodeIdList.length > 0) {\n                // if the children list CHANGED\n                latestChildrenNodeIdList.forEach(function (nodeId) {\n                  Utils.cleanForceLayoutData(_this.nodeFetcher(nodeId, true));\n                });\n              }\n            }\n          }\n        } // REMOVE ALL EXPAND INFO\n\n\n        this.expandInfo = {}; // Calculate relations for latest data\n\n        this.calculateGraphicData(); // Restore expand state\n\n        latestExpandedKeys.forEach(function (nodeId) {\n          return _this.expandNode(_this.nodeFetcher(nodeId, true));\n        });\n      }\n\n      return removedIdList;\n    }\n    /**\n     * Return children elements of node\n     * @param {object} nodeData - REAL node data\n     * @returns {Array<string>} List of REAL NODE id\n     */\n\n  }, {\n    key: \"childrenElementIdList\",\n    value: function childrenElementIdList(nodeData) {\n      var nodeList = [];\n      Constants.EXPAND_KEYS.forEach(function (expandKeyName) {\n        if (nodeData.hasOwnProperty(expandKeyName)) {\n          if (Array.isArray(nodeData[expandKeyName])) {\n            nodeData[expandKeyName].forEach(function (d) {\n              return nodeList.push(d);\n            });\n          }\n        }\n      });\n      return nodeList;\n    }\n    /**\n     * Tell if a node can expand by interacting with the node\n     *\n     * @param {object} node - need to pass in the REAL node info\n     * @returns {boolean} if a node can be expanded\n     */\n\n  }, {\n    key: \"canExpand\",\n    value: function canExpand(node) {\n      var canExpand = false;\n      Constants.EXPAND_KEYS.forEach(function (keyName) {\n        if (node.hasOwnProperty(keyName)) {\n          canExpand = true;\n        }\n      });\n      return canExpand;\n    }\n    /**\n     * Calculate Links and Hulls based on current nodes\n     */\n\n  }, {\n    key: \"calculateGraphicData\",\n    value: function calculateGraphicData() {\n      // Reset Links and Hulls to prevent weird relations\n      this.links = [];\n      this.hulls = [];\n      Utils.generateCentroidLinks(this.nodes, this.links, this.nodeFetcher);\n      Utils.calculateVisibleLinks(this.nodes, this.links, this.hulls, this.expandInfo, this.nodeFetcher);\n      Utils.updateHullCoordinate(this.hulls, this.nodeFetcher);\n    }\n    /**\n     * Update hull coordinate for path generation\n     * @returns {Array<object>} new hull info\n     */\n\n  }, {\n    key: \"updateHullCoordinate\",\n    value: function updateHullCoordinate() {\n      Utils.updateHullCoordinate(this.hulls, this.nodeFetcher);\n      return this.hulls;\n    }\n    /**\n     * Return a node reference with nodeId\n     *\n     * @param {string} nodeId - The REAL node id\n     * @param {boolean} pretty - If pretty is true, RETURN node wrapper instead of node\n     * @return {object|undefined} The node info\n     */\n\n  }, {\n    key: \"nodeFetcher\",\n    value: function nodeFetcher(nodeId) {\n      var pretty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var nodeInfo = this.data[nodeId];\n      return nodeInfo == null ? null : pretty ? nodeInfo : nodeInfo.metadata;\n    }\n    /**\n     * See if the node is already expanded\n     *\n     * @param {string|object} any - nodeId or node reference\n     * @returns {boolean} If the node is already expanded\n     */\n\n  }, {\n    key: \"isNodeExpanded\",\n    value: function isNodeExpanded(any) {\n      var nodeId;\n\n      if ((0, _typeof2.default)(any) === 'object') {\n        nodeId = any.metadata.id;\n      } else {\n        nodeId = any;\n      }\n\n      return this.expandInfo.hasOwnProperty(nodeId);\n    }\n    /**\n     * Expand node with id\n     *\n     * @param {object} nodeWrapper - node wrapper reference\n     * @returns {boolean} if the expansion success\n     */\n\n  }, {\n    key: \"expandNode\",\n    value: function expandNode(nodeWrapper) {\n      if (nodeWrapper) {\n        var nodeId = nodeWrapper.metadata.id; // ensure the node is NOT expanded\n\n        if (!this.isNodeExpanded(nodeId)) {\n          var targetNode = this.nodeFetcher(nodeId);\n\n          if (targetNode) {\n            Utils.expandNode(targetNode, this.nodes, this.expandInfo, this.nodeFetcher);\n            this.calculateGraphicData();\n          }\n\n          return true;\n        }\n\n        return false;\n      }\n    }\n    /**\n     * Shrink node with id\n     *\n     * @param {object} nodeWrapper - node wrapper reference\n     * @returns {boolean} if the shrink success\n     */\n\n  }, {\n    key: \"shrinkNode\",\n    value: function shrinkNode(nodeWrapper) {\n      var nodeId = nodeWrapper.metadata.id; // ensure the node is expanded\n\n      if (this.isNodeExpanded(nodeId)) {\n        var targetNode = this.nodeFetcher(nodeId);\n\n        if (targetNode) {\n          Utils.shrinkNode(targetNode, this.nodes, this.expandInfo, this.nodeFetcher);\n          this.calculateGraphicData();\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Prepare space for node to expand\n     *\n     * @param {object} nodeWrapper - node wrapper reference\n     */\n\n  }, {\n    key: \"prepareSpace\",\n    value: function prepareSpace(nodeWrapper) {\n      if (nodeWrapper) {\n        Utils.startSpacePrepare(nodeWrapper, this.nodes);\n      }\n    }\n    /**\n     * Remove the large collisionRadius after preparation\n     */\n\n  }, {\n    key: \"prepareSpaceDone\",\n    value: function prepareSpaceDone() {\n      Utils.endSpacePrepare(this.nodes);\n    }\n    /**\n     * Generate d3 purpose data\n     * @returns {{nodes: Array<object>, links: Array<object>, hulls: Array<object>}} D3 render data\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse() {\n      var _this2 = this;\n\n      var data = {\n        nodes: [],\n        links: (0, _toConsumableArray2.default)(this.links),\n        hulls: (0, _toConsumableArray2.default)(this.hulls)\n      };\n      this.nodes.forEach(function (d) {\n        return data.nodes.push(_this2.nodeFetcher(d.id, true));\n      });\n      return data;\n    }\n  }]);\n  return DataModel;\n}();\n\nvar _default = DataModel;\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/main/webapp/visual/data-model/data-model.js?");

/***/ }),

/***/ "./src/main/webapp/visual/data-model/server-data/server-data.js":
/*!**********************************************************************!*\
  !*** ./src/main/webapp/visual/data-model/server-data/server-data.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/typeof.js\"));\n\nvar _objectSpread2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/objectSpread */ \"./node_modules/@babel/runtime/helpers/objectSpread.js\"));\n\nvar _keys = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/core-js/object/keys */ \"./node_modules/@babel/runtime/core-js/object/keys.js\"));\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _lodash = _interopRequireDefault(__webpack_require__(/*! lodash */ \"./node_modules/lodash/lodash.js\"));\n\nvar Utils = _interopRequireWildcard(__webpack_require__(/*! ./utils */ \"./src/main/webapp/visual/data-model/server-data/utils.js\"));\n\n/**\n * The function is trying to clean up the server side data for local DataModel\n *\n * The function would do these following steps\n *\n *\n * 1. Assign NODE-ID for better reference in Array\n * 2. Remove useless URL in KEY NAME\n * 3. Remove useless ONE-ELEMENT-ARRAY\n *\n * Few examples\n *\n * [1. ASSIGN-NODE-ID] NOTE: This function CHANGE the pass-in object, and RETURN NOTHING\n *\n * For example:\n * {\n *   \"aws-asia-s3\": {\n *     \"isAlias\": \"aws-na-s3\",\n *     \"hasNode\": [ ... ]\n *   }\n * }\n *\n * We would want to assign the ID to the node information body\n *\n * {\n *   \"aws-asia-s3\": {\n *     \"id\": \"aws-asia-s3\",  // I have an ID now, YAY\n *     \"isAlias\": \"aws-na-s3\",\n *     \"hasNode\": [ ... ]\n *   }\n * }\n */\nvar ServerData =\n/*#__PURE__*/\nfunction () {\n  function ServerData() {\n    (0, _classCallCheck2.default)(this, ServerData);\n  }\n\n  (0, _createClass2.default)(ServerData, null, [{\n    key: \"parse\",\n\n    /**\n     * Actually parse the server data for local Data Model, WE MIGHT MODIFY THE PASSED IN OBJECT\n     *\n     * @param {object} serverData - Javascript Object directly parsed from HTTP API request from StackV server\n     * @param {object} options - Extra parsing options (Not-Currently implemented)\n     * @returns {{ topLevel: Object.<string, object>, serverData: object }}\n     */\n    value: function parse(serverData) {\n      serverData = _lodash.default.cloneDeep(serverData); // preserve TOP_LEVEL Node data\n\n      var topLevelNodeIdList = (0, _keys.default)(serverData);\n      var serverDataKeyStructure = {};\n      var realServerData = {};\n      topLevelNodeIdList.forEach(function (topLevelNodeId) {\n        if (serverData[topLevelNodeId]) {\n          var innerData = JSON.parse(serverData[topLevelNodeId].json);\n          realServerData = (0, _objectSpread2.default)({}, realServerData, innerData);\n          serverDataKeyStructure[topLevelNodeId] = (0, _keys.default)(innerData);\n          serverDataKeyStructure[topLevelNodeId] = (0, _keys.default)(innerData);\n        } else {\n          serverDataKeyStructure[topLevelNodeId] = [];\n        }\n      });\n      var versionRecord = {};\n      topLevelNodeIdList.forEach(function (topLevelId) {\n        if (serverData[topLevelId] != null) {\n          versionRecord[topLevelId] = {\n            time: serverData[topLevelId].time,\n            uuid: serverData[topLevelId].uuid\n          };\n        } else {\n          versionRecord[topLevelId] = {\n            time: -1,\n            uuid: '30624700-30624770-534202-13942-43140624' // dummy uuid\n\n          };\n        }\n      });\n\n      ServerData._parseHelper(realServerData);\n\n      return {\n        topLevel: serverDataKeyStructure,\n        serverData: ServerData._simplifyFormat(realServerData),\n        versionRecord: versionRecord\n      };\n    }\n    /**\n     * Parse the server data recursively\n     *\n     * @param {object} serverData - Javascript Object directly parsed from HTTP API request from StackV server\n     * @private\n     */\n\n  }, {\n    key: \"_parseHelper\",\n    value: function _parseHelper(serverData) {\n      /**\n       * Server data must in this FORMAT\n       * {\n       *   \"NODE_ID_1\": { ... },\n       *   \"NODE_ID_2\": { ... },\n       * }\n       */\n      if (serverData !== null && (0, _typeof2.default)(serverData) === 'object') {\n        for (var keyName in serverData) {\n          if (serverData.hasOwnProperty(keyName)) {\n            // recursively parse data\n            ServerData._parseHelper(serverData[keyName]); // parse current object\n\n\n            if (Utils.shouldAssignNodeId(keyName)) {\n              // Assign NODE-ID (KEY NAME) to node information body\n              serverData[keyName].id = keyName;\n            } // remove weird keyName like http://schema.org/hasNode\n\n\n            if (Utils.containSchemaURL(keyName)) {\n              var newKeyName = Utils.removeSchemeURL(keyName);\n              serverData[newKeyName] = serverData[keyName];\n              delete serverData[keyName];\n              keyName = newKeyName;\n            }\n\n            if (Utils.containSchemaURL(serverData[keyName])) {\n              serverData[keyName] = Utils.removeSchemeURL(serverData[keyName]);\n            } // remove ONE-ELEMENT array, assign array[0] to top-level object\n\n\n            if (Utils.shouldRemoveOneElementArray(keyName)) {\n              // double check if the content is Array\n              if (Array.isArray(serverData[keyName])) {\n                if (serverData[keyName].length === 0) {\n                  serverData[keyName] = null;\n                } else {\n                  serverData[keyName] = serverData[keyName][0];\n                }\n              }\n            }\n\n            if ((0, _typeof2.default)(serverData[keyName]) === 'object' && !Array.isArray(serverData[keyName])) {\n              if (serverData[keyName].hasOwnProperty('value') && serverData[keyName].hasOwnProperty('type')) {\n                if ((0, _keys.default)(serverData[keyName]).length === 2) {\n                  if (serverData[keyName].type === 'uri' || serverData[keyName].type === 'bnode' || serverData[keyName].type === 'literal') {\n                    serverData[keyName] = serverData[keyName].value;\n                  }\n\n                  if (serverData[keyName].type === 'bnode') {// @todo implement the node reference for TAG NODES\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    /**\n     * Generate new format nodes\n     *\n     * @param {object} serverData - parsed server data\n     * @returns {object} KEY -> VALUE pair of new format nodes\n     * @private\n     */\n\n  }, {\n    key: \"_simplifyFormat\",\n    value: function _simplifyFormat(serverData) {\n      var data = {};\n\n      for (var keyName in serverData) {\n        if (serverData.hasOwnProperty(keyName)) {\n          data[keyName] = {\n            id: _lodash.default.uniqueId('node_'),\n            metadata: serverData[keyName]\n          };\n        }\n      }\n\n      return data;\n    }\n  }]);\n  return ServerData;\n}();\n\nvar _default = ServerData;\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/main/webapp/visual/data-model/server-data/server-data.js?");

/***/ }),

/***/ "./src/main/webapp/visual/data-model/server-data/utils.js":
/*!****************************************************************!*\
  !*** ./src/main/webapp/visual/data-model/server-data/utils.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shouldRemoveOneElementArray = shouldRemoveOneElementArray;\nexports.containSchemaURL = containSchemaURL;\nexports.removeSchemeURL = removeSchemeURL;\nexports.shouldAssignNodeId = shouldAssignNodeId;\n\n/**\n * In some situation (XML convert to JSON issue), some KEY did contain an Array\n * with only 1 child element ONLY\n *\n * For better data modelling, we are removing those ONE-ELEMENT-ARRAY,\n * and replace the ONE-ELEMENT-ARRAY with the ONLY-CHILD data\n *\n * For example\n *\n * {\n *   \"id\": \"aws-asia-s3\",\n *   \"isAlias\": [ { value: \"aws-na-s3\" } ],  // Useless ONE-ELEMENT-ARRAY\n * }\n *\n * would become\n *\n * {\n *   \"id\": \"aws-asia-s3\",\n *   \"isAlias\": \"aws-na-s3\",  // REPLACE IT, YAY!\n * }\n *\n * @returns {boolean} Should replace ONE-ELEMENT-ARRAY OR not\n */\nfunction shouldRemoveOneElementArray(keyName) {\n  return shouldRemoveOneElementArray_keyList.indexOf(keyName) !== -1;\n}\n/**\n * Private constant for shouldRemoveArray(keyName) function\n *\n * @type {Array<string>}\n */\n\n\nvar shouldRemoveOneElementArray_keyList = ['value', 'type', 'name', 'isAlias', 'labeltype'];\n/**\n * Determine if the string have useless schema URL\n *\n * @param {string} str - A string\n * @returns {boolean} If the the string contains useless schema URL OR not\n */\n\nfunction containSchemaURL(str) {\n  return typeof str === 'string' && (str.startsWith('http://schemas.ogf.org') || str.startsWith('http://www.w3.org'));\n}\n/**\n * Remove the scheme URL in string\n * @param {string} str - A string\n * @returns {string} A string without scheme URL\n */\n\n\nfunction removeSchemeURL(str) {\n  return str.replace(/^http(.+)#/gi, '');\n}\n/**\n * Determine if the (Object) need to assign NODE-ID\n *\n * @param {string} keyName - (Object) KEY NAME\n * @returns {boolean} If the KEY NAME should assign a NODE-ID to information body OR not\n */\n\n\nfunction shouldAssignNodeId(keyName) {\n  return keyName.startsWith('urn:ogf') || keyName.startsWith('_:');\n}\n\n//# sourceURL=webpack:///./src/main/webapp/visual/data-model/server-data/utils.js?");

/***/ }),

/***/ "./src/main/webapp/visual/data-model/utils.js":
/*!****************************************************!*\
  !*** ./src/main/webapp/visual/data-model/utils.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.prepareData = prepareData;\nexports.generateCentroidLinks = generateCentroidLinks;\nexports.updateHullCoordinate = updateHullCoordinate;\nexports.calculateVisibleLinks = calculateVisibleLinks;\nexports.expandNode = expandNode;\nexports.shrinkNode = shrinkNode;\nexports.cleanForceLayoutData = cleanForceLayoutData;\nexports.endSpacePrepare = endSpacePrepare;\nexports.startSpacePrepare = startSpacePrepare;\n\nvar _slicedToArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ \"./node_modules/@babel/runtime/helpers/slicedToArray.js\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ \"./node_modules/@babel/runtime/helpers/toConsumableArray.js\"));\n\nvar _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/typeof.js\"));\n\nvar _keys = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/core-js/object/keys */ \"./node_modules/@babel/runtime/core-js/object/keys.js\"));\n\nvar Constants = _interopRequireWildcard(__webpack_require__(/*! ./consts */ \"./src/main/webapp/visual/data-model/consts.js\"));\n\nvar d3 = _interopRequireWildcard(__webpack_require__(/*! d3 */ \"./node_modules/d3/index.js\"));\n\n/**\n * Put all new render attributes into sub-key\n *\n * @param {object} node - node reference\n * @param {string} key - node attr key\n * @param {*} value - node attr value\n */\nfunction setNodeAttribute(node, key, value) {\n  if (!node.hasOwnProperty('renderConfig')) {\n    node['renderConfig'] = {};\n  }\n\n  node['renderConfig'][key] = value;\n}\n/**\n * Prepare nodes data for further calculation\n *\n * @param {object|Array} nodeList - Clean-up-ed node data, [ NODE ] or { NODE_ID: NODE }\n * @param {Object.<string, Array<string>>} serverDataStructure - A list of pre-calculated top-level nodeId (REAL ID) map\n * @param {Function} nodeFetcher - Function(nodeId: string): Object\n * @returns {Array<object>} The top-level node list\n */\n\n\nfunction prepareData(nodeList, serverDataStructure, nodeFetcher) {\n  /**\n   * How this wrapper works:\n   *\n   * For a topology, if any node is not refer by any other node, it is considered as TopNode\n   *\n   * NOTE: Backward refer is not calculated\n   *\n   * @param nodeId - node id\n   * @returns {object} node reference\n   */\n  var topLevelNodeIdList = (0, _keys.default)(serverDataStructure);\n\n  var wrappedNodeFetcher = function wrappedNodeFetcher(nodeId) {\n    return nodeFetcher(nodeId);\n  };\n\n  prepareData_helper(nodeList, wrappedNodeFetcher);\n\n  for (var keyName in nodeList) {\n    if (nodeList.hasOwnProperty(keyName)) {\n      (function () {\n        var node = nodeList[keyName].metadata;\n        /**\n         * Assign directParentList\n         */\n\n        for (var _keyName in node) {\n          if (node.hasOwnProperty(_keyName)) {\n            if (Array.isArray(node[_keyName])) {\n              if (Constants.RECURSION_BLACK_LIST_KEY_NAME_LIST.indexOf(_keyName) === -1) {\n                var _nodeList = node[_keyName];\n\n                for (var i = 0; i < _nodeList.length; i++) {\n                  // console.log('query', nodeList[i]);\n                  var childNode = nodeFetcher(_nodeList[i]);\n\n                  if (childNode) {\n                    if (!childNode.hasOwnProperty('directParentList') || !Array.isArray(childNode['directParentList'])) {\n                      childNode['directParentList'] = [];\n                    }\n\n                    if (childNode['directParentList'].indexOf(node.id) === -1) {\n                      childNode['directParentList'].push(node.id);\n                    }\n\n                    if (_keyName === 'hasBidirectionalPort') {\n                      if (!childNode.hasOwnProperty('isPortOf') || !Array.isArray(childNode['isPortOf'])) {\n                        childNode['isPortOf'] = [];\n                      }\n\n                      if (childNode['isPortOf'].indexOf(node.id) === -1) {\n                        childNode['isPortOf'].push(node.id);\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        /**\n         * Remove hasBidirectionalPort nodes from aggregateChildren\n         */\n\n\n        if (node.hasOwnProperty('hasBidirectionalPort') && node.hasOwnProperty('aggregateChildren')) {\n          node['aggregateChildren'] = node['aggregateChildren'].filter(function (d) {\n            return node['hasBidirectionalPort'].indexOf(d) === -1;\n          });\n        }\n        /**\n         * Assign default safe radius for all\n         */\n\n\n        setNodeAttribute(node, 'collisionRadius', Constants.DEFAULT_COLLISION_RADIUS);\n\n        if (topLevelNodeIdList.indexOf(node.id) !== -1) {\n          /**\n           * MARK TOP-LEVEL-NODE\n           */\n          setNodeAttribute(node, 'top', true);\n        } else {\n          /**\n           * No Links inside Top-Level nodes\n           */\n          delete node['aggregateChildren'];\n        }\n      })();\n    }\n  }\n\n  for (var _keyName2 in nodeList) {\n    if (nodeList.hasOwnProperty(_keyName2)) {\n      var node = nodeList[_keyName2].metadata;\n      /**\n       * BACK-UP INITIAL DATA\n       */\n\n      node['__orig__'] = _.cloneDeep(node);\n    }\n  }\n\n  return topLevelNodeIdList.map(function (nodeId) {\n    return nodeFetcher(nodeId);\n  });\n}\n/**\n * Prepare nodes data for further calculation, recursion helper\n *\n * Basically, when we access the Top-Level node, we cannot see the children (children's children) node\n * However, we need to build Top-Level node, AND show the relationship\n * So, assign all children nodes to parent node\n *\n * @param {object} mysteryNode - JSON / Object server data\n * @param {Function} nodeFetcher - Function(nodeId: string): Object\n * @returns {Array<object>} Aggregated data for recursion purpose\n * @private\n */\n\n\nfunction prepareData_helper(mysteryNode, nodeFetcher) {\n  // NOTE: Would accept both Object AND Array\n  if (mysteryNode !== null && (0, _typeof2.default)(mysteryNode) === 'object') {\n    if (mysteryNode.hasOwnProperty('metadata')) {\n      mysteryNode = mysteryNode.metadata;\n    }\n\n    if (!mysteryNode.hasOwnProperty('id')) {\n      // Non Node object, might be an Array or outer Map\n      var aggregateChildren = [];\n\n      for (var keyName in mysteryNode) {\n        if (mysteryNode.hasOwnProperty(keyName)) {\n          /**\n           * MYSTERY NODE DATA\n           *\n           * Since we say this is a mystery data, because it can be\n           *\n           * 1. Node Id - String (When serverData is an OUTER MAP)\n           * 2. Node Reference - Object (When serverData is an Array)\n           *\n           */\n          var mysteryNodeData = mysteryNode[keyName];\n\n          if (typeof mysteryNodeData === 'string') {\n            // Turn Node Id -> Node Reference\n            mysteryNodeData = nodeFetcher(mysteryNodeData);\n          }\n\n          mergeAggregateChildren(aggregateChildren, prepareData_helper(mysteryNodeData, nodeFetcher));\n        }\n      }\n\n      return aggregateChildren;\n    } else {\n      // Inside a Node object\n      var _aggregateChildren = [];\n\n      for (var _keyName3 in mysteryNode) {\n        if (mysteryNode.hasOwnProperty(_keyName3)) {\n          if (Array.isArray(mysteryNode[_keyName3])) {\n            if (Constants.RECURSION_BLACK_LIST_KEY_NAME_LIST.indexOf(_keyName3) === -1) {\n              mergeAggregateChildren(_aggregateChildren, mysteryNode[_keyName3]);\n              mergeAggregateChildren(_aggregateChildren, prepareData_helper(mysteryNode[_keyName3], nodeFetcher));\n            }\n          }\n        }\n      }\n      /**\n       * We also want to assign parent node, to generate visualization nodes\n       */\n\n\n      for (var i = 0; i < _aggregateChildren.length; i++) {\n        var node = nodeFetcher(_aggregateChildren[i]);\n\n        if (node) {\n          if (!node.hasOwnProperty('parentList') || !Array.isArray(node['parentList'])) {\n            node['parentList'] = [];\n          } // ensure no duplicate\n\n\n          if (node['parentList'].indexOf(mysteryNode.id) === -1) {\n            // console.log(mysteryNode);\n            node['parentList'].push(mysteryNode.id);\n          }\n        }\n      }\n\n      mysteryNode['aggregateChildren'] = _aggregateChildren;\n      return _aggregateChildren;\n    }\n  }\n}\n/**\n * Merge extraNodeList into aggregateChildren, without DUPLICATION\n *\n * @param {Array<object>} aggregateChildren - will merge extra nodes into this Array\n * @param {Array<object>} extraNodeIdList - extra nodes\n * @private\n */\n\n\nfunction mergeAggregateChildren(aggregateChildren, extraNodeIdList) {\n  if (extraNodeIdList) {\n    for (var i = 0; i < extraNodeIdList.length; i++) {\n      var extraNodeId = extraNodeIdList[i];\n\n      if (typeof extraNodeId === 'string' && aggregateChildren.indexOf(extraNodeId) === -1) {\n        aggregateChildren.push(extraNodeId);\n      }\n    }\n  }\n}\n/**\n * If there is no relations b/t nodes, it would float randomly, so we create dummy\n * Links to add force to the center of EXPANDED CLUSTERS\n *\n * @param {Array<object>} nodes - The list of current nodes\n * @param {Array<object>} links - Would modify and push new links to this array\n * @param {Function} nodeFetcher - Function(nodeId: string): Object\n */\n\n\nfunction generateCentroidLinks(nodes, links, nodeFetcher) {\n  nodes.forEach(function (node) {\n    if (node.hasOwnProperty('directParentList')) {\n      // loop over every direct parent\n      node['directParentList'].forEach(function (directParentNodeId) {\n        var parentNode = nodeFetcher(directParentNodeId);\n\n        if (parentNode) {\n          // ensure parent node is in view hierarchy\n          if (nodes.indexOf(parentNode) !== -1) {\n            links.push({\n              source: nodeFetcher(node.id, true),\n              target: nodeFetcher(parentNode.id, true),\n              metadata: {\n                sourceNode: node,\n                targetNode: parentNode,\n                centroid: true,\n                required: false,\n                length: 15,\n                strength: 1\n              }\n            });\n          }\n        }\n      });\n    }\n  });\n}\n/**\n * Generate convex hull coordinate, MUST CALL EVERY TICK\n *\n * @param {Array<object>} hulls - Would modify and generate hull curve to this array\n * @param {Function} nodeFetcher - Function(nodeId: string): Object\n */\n\n\nfunction updateHullCoordinate(hulls, nodeFetcher) {\n  function validate(arr) {\n    // arr.forEach(d => isNaN(d) ? console.log('NON NUM') : null );\n    return arr;\n  }\n\n  hulls.forEach(function (hullInfo) {\n    var hullPathInfo = [];\n\n    for (var i = 0; i < hullInfo.hullNodes.length; i++) {\n      var d = nodeFetcher(hullInfo.hullNodes[i].id, true);\n      hullPathInfo.push(validate([d.x - Constants.HULL_OFFSET, d.y - Constants.HULL_OFFSET]));\n      hullPathInfo.push(validate([d.x - Constants.HULL_OFFSET, d.y + Constants.HULL_OFFSET]));\n      hullPathInfo.push(validate([d.x + Constants.HULL_OFFSET, d.y - Constants.HULL_OFFSET]));\n      hullPathInfo.push(validate([d.x + Constants.HULL_OFFSET, d.y + Constants.HULL_OFFSET]));\n    }\n\n    if (hullInfo.hasOwnProperty('children')) {\n      for (var _i = 0; _i < hullInfo.children.length; _i++) {\n        var _d = nodeFetcher(hullInfo.children[_i].id, true);\n\n        hullPathInfo.push(validate([_d.x - 2 * Constants.HULL_OFFSET, _d.y - 2 * Constants.HULL_OFFSET]));\n        hullPathInfo.push(validate([_d.x - 2 * Constants.HULL_OFFSET, _d.y + 2 * Constants.HULL_OFFSET]));\n        hullPathInfo.push(validate([_d.x + 2 * Constants.HULL_OFFSET, _d.y - 2 * Constants.HULL_OFFSET]));\n        hullPathInfo.push(validate([_d.x + 2 * Constants.HULL_OFFSET, _d.y + 2 * Constants.HULL_OFFSET]));\n      }\n    }\n\n    var path = d3.polygonHull(hullPathInfo);\n    hullInfo['__path_raw__'] = path;\n    hullInfo['path'] = Constants.HULL_CURVE(path);\n  });\n}\n/**\n * Calculate visible links AND generate convex hulls\n *\n * @param {Array<object>} nodes - The list of current nodes\n * @param {Array<object>} links - Would modify and push new links to this array\n * @param {Array<object>} hulls - Would modify and push new hulls to this array\n * @param {object} expandInfo - The expanded nodes info\n * @param {Function} nodeFetcher - Function(nodeId: string): Object\n */\n\n\nfunction calculateVisibleLinks(nodes, links, hulls, expandInfo, nodeFetcher) {\n  nodes.forEach(function (node) {\n    /**\n     * This code block will build the link for CHILDREN ONLY, NOT IT-SELF\n     */\n    if (node.hasOwnProperty('aggregateChildren')) {\n      for (var j = 0; j < node['aggregateChildren'].length; j++) {\n        var childNode = nodeFetcher(node['aggregateChildren'][j]);\n        generateLinkForNode(node, childNode, nodes, links, nodeFetcher, expandInfo);\n      }\n    }\n    /**\n     * This code block will build the link for Ports Only\n     */\n\n\n    if (node.hasOwnProperty('hasBidirectionalPort')) {\n      for (var _j = 0; _j < node['hasBidirectionalPort'].length; _j++) {\n        var _childNode = nodeFetcher(node['hasBidirectionalPort'][_j]);\n\n        generateLinkForNode(node, _childNode, nodes, links, nodeFetcher, expandInfo, _childNode);\n      }\n    }\n    /**\n     * BUILD LINK FOR IT SELF\n     */\n\n\n    generateLinkForNode(node, node, nodes, links, nodeFetcher, expandInfo);\n  });\n  /**\n   * build initial hulls\n   */\n\n  for (var nodeId in expandInfo) {\n    if (expandInfo.hasOwnProperty(nodeId)) {\n      var expandData = expandInfo[nodeId];\n      var hullInfo = {\n        id: nodeId,\n        hullNodes: (0, _toConsumableArray2.default)(expandData.nodes),\n        physicalNodes: allChildrenNode(nodeId, nodeFetcher, expandInfo)\n      };\n\n      if (expandData.hasOwnProperty('children')) {\n        hullInfo['children'] = [];\n\n        for (var i = 0; i < expandData['children'].length; i++) {\n          var childId = expandData['children'][i];\n          hullInfo['children'] = (0, _toConsumableArray2.default)(hullInfo['children']).concat((0, _toConsumableArray2.default)(expandInfo[childId]['nodes']), [nodeFetcher(childId)]);\n        }\n      }\n\n      hulls.push(hullInfo);\n    }\n  }\n}\n/**\n * List all children node for a OPEN node\n *\n * @param {string} nodeId - node id\n * @param {Function} nodeFetcher - Function(nodeId: string): Object\n * @param {object} expandInfo - expand info in Data Model\n * @returns {Array<object>} A list of all sub nodes\n * @private\n */\n\n\nfunction allChildrenNode(nodeId, nodeFetcher, expandInfo) {\n  var nodeList = [nodeFetcher(nodeId)];\n  allChildrenNode_helper(nodeId, nodeFetcher, expandInfo, nodeList);\n  return nodeList;\n}\n/**\n * Helper function to list all children node for a OPEN node\n *\n * @param {string} nodeId - node id\n * @param {Function} nodeFetcher - Function(nodeId: string): Object\n * @param {object} expandInfo - expand info in Data Model\n * @param {object} nodeList - all children node list\n * @private\n */\n\n\nfunction allChildrenNode_helper(nodeId, nodeFetcher, expandInfo, nodeList) {\n  var expandData = expandInfo[nodeId];\n\n  if (expandData && expandData.nodes) {\n    expandData.nodes.forEach(function (d) {\n      nodeList.push(d);\n      allChildrenNode_helper(d.id, nodeFetcher, expandInfo, nodeList);\n    });\n  }\n}\n/**\n * This function will try to find all links from childNode -> ANY NODE IN VIEW HIERARCHY\n * And will modify the links in the argument\n *\n * @param {object} parentNode - node reference\n * @param {object} realSourceNode - node reference REAL SOURCE\n * @param {Array<object>} nodes - current top-level nodes in view hierarchy\n * @param {Array<object>} links - link pool for d3\n * @param {Function} nodeFetcher - Function(nodeId: string): Object\n * @param {object} expandInfo - expand info in Data Model\n * @param {object=} overrideRealSourceNode - Provide and override source node for TOP-LEVEL nodes, but PREPARE as non-proxy link\n * @private\n */\n\n\nfunction generateLinkForNode(parentNode, realSourceNode, nodes, links, nodeFetcher, expandInfo) {\n  var overrideRealSourceNode = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n\n  // If there is possible links\n  if (realSourceNode && realSourceNode.hasOwnProperty('isAlias')) {\n    // check if target node is in current view hierarchy\n    var realTargetNode = nodeFetcher(realSourceNode['isAlias']);\n\n    if (realTargetNode) {\n      var _isInViewHierarchy = isInViewHierarchy(realTargetNode, nodes),\n          _isInViewHierarchy2 = (0, _slicedToArray2.default)(_isInViewHierarchy, 2),\n          topLevelNodeId = _isInViewHierarchy2[0],\n          isProxyLink = _isInViewHierarchy2[1];\n\n      if (topLevelNodeId) {\n        /**\n         * Hurray! We found a Link\n         *\n         * We render the link ONLY IF they are not from the SAME PARENT NODE\n         */\n        var linkSourceNodeId = parentNode.id;\n        var linkTargetNodeId = topLevelNodeId;\n\n        if (linkSourceNodeId !== linkTargetNodeId) {\n          // console.log(`Found Link ${linkSourceNodeId} -> ${linkTargetNodeId}`);\n          var sourceNode = nodeFetcher(linkSourceNodeId);\n          var targetNode = nodeFetcher(linkTargetNodeId);\n\n          if (!hasLink(links, sourceNode, targetNode)) {\n            var sourceExpanded = expandInfo.hasOwnProperty(sourceNode.id);\n            var targetExpanded = expandInfo.hasOwnProperty(targetNode.id);\n            var sourceProxy = overrideRealSourceNode ? false : parentNode !== realSourceNode;\n            var targetProxy = isProxyLink;\n\n            if (!overrideRealSourceNode) {\n              realSourceNode = nodeFetcher(linkSourceNodeId);\n            }\n\n            var sourceRequired = !sourceExpanded || !sourceProxy;\n            var targetRequired = !targetExpanded || !targetProxy;\n            var linkRequired = sourceRequired && targetRequired; // const sourceSize = childrenCount(sourceNode, expandInfo);\n            // const targetSize = childrenCount(targetNode, expandInfo);\n\n            var linkSize = 100; // let newLinkSize = linkLength(sourceSize) + linkLength(targetSize);\n            // if (newLinkSize > linkSize) {\n            //   linkSize = newLinkSize;\n            // }\n\n            var linkInfo = {\n              source: nodeFetcher(sourceNode.id, true),\n              target: nodeFetcher(targetNode.id, true),\n              metadata: {\n                sourceNode: sourceNode,\n                targetNode: targetNode,\n                sourceProxy: sourceProxy,\n                targetProxy: targetProxy,\n                required: linkRequired,\n                length: linkSize,\n                strength: 0.1\n              }\n            };\n\n            if (sourceProxy) {\n              linkInfo['metadata']['realSourceNode'] = realSourceNode;\n            }\n\n            if (overrideRealSourceNode) {\n              linkInfo['metadata']['realSourceNode'] = overrideRealSourceNode;\n            }\n\n            if (targetProxy) {\n              linkInfo['metadata']['realTargetNode'] = realTargetNode;\n            }\n\n            links.push(linkInfo);\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Detect if same link already exists in link pool, prevent adding duplicated line (performance purpose)\n *\n * @param links {Array<object>} links - Link pool\n * @param {object} sourceNode - source REAL node reference\n * @param {object} targetNode - target REAL node reference\n * @returns {boolean} Return TRUE if link already exists in link pool\n * @private\n */\n\n\nfunction hasLink(links, sourceNode, targetNode) {\n  for (var i = 0; i < links.length; i++) {\n    var linkInfo = links[i];\n\n    if (linkInfo.source.metadata === sourceNode && linkInfo.target.metadata === targetNode) {\n      return true;\n    } else if (linkInfo.source.metadata === targetNode && linkInfo.target.metadata === sourceNode) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * This function will try to compare the node['parentList'] Array with current Top-Level Nodes,\n * If they have the same element, so the node and its link should be visible\n *\n * ** WHAT IS PROXY LINK\n *\n * 1. It means that sourceNode -> targetNode is not declared, but it is indicated by children\n *\n * @param {object} targetNode - node reference\n * @param {Array<object>} nodes - current top-level nodes\n * @returns {Array<string|null|boolean>} Will return the target top-level id AND if it is proxy link\n * @private\n */\n\n\nfunction isInViewHierarchy(targetNode, nodes) {\n  var nodeIdList = nodes.map(function (d) {\n    return d.id;\n  });\n  var targetTopLevelId = null;\n  var isProxyLink = true;\n\n  if (nodeIdList.indexOf(targetNode.id) !== -1) {\n    // TARGET NODE IS IN VIEW HIERARCHY\n    targetTopLevelId = targetNode.id;\n    isProxyLink = false;\n  }\n\n  if (isProxyLink) {\n    for (var i = 0; i < nodeIdList.length; i++) {\n      var nodeId = nodeIdList[i];\n\n      if (targetNode.hasOwnProperty('parentList') && targetNode['parentList'].indexOf(nodeId) !== -1) {\n        /**\n         * WE PICK THE FINAL ONE\n         * SINCE IT CAN BE THE EXPANDED NODE\n         */\n        targetTopLevelId = nodeId;\n        isProxyLink = true;\n      }\n    }\n  }\n  /**\n   * See if target node is a hardware node of targetTopLevelNode\n   */\n\n\n  if (targetNode.hasOwnProperty('isPortOf') && Array.isArray(targetNode['isPortOf'])) {\n    if (targetNode['isPortOf'].indexOf(targetTopLevelId) !== -1) {\n      isProxyLink = false;\n    }\n  }\n\n  return [targetTopLevelId, isProxyLink];\n}\n/**\n * Expand a node to view hierarchy\n *\n * @param {object} targetNode - node reference\n * @param {Array<object>} nodes - node list, would modify\n * @param {object} expandInfo - expand info\n * @param {Function} nodeFetcher - nodeFetcher(nodeId: string): Object\n */\n\n\nfunction expandNode(targetNode, nodes, expandInfo, nodeFetcher) {\n  setNodeAttribute(targetNode, 'expand', false); // back-up original position\n\n  if (!targetNode.hasOwnProperty('__original_point_backup__')) {\n    targetNode['__original_point_backup__'] = {\n      x: targetNode.fx,\n      y: targetNode.fy\n    };\n  }\n\n  expandNodeToViewHierarchy(targetNode, nodes, expandInfo, nodeFetcher);\n}\n/**\n * This method will expand (join) all possible nodes to the current view hierarchy\n *\n * @param {object} targetNode - node reference\n * @param {Array<object>} nodes - nodes in current view hierarchy\n * @param {object} expandInfo - expand info\n * @param {Function} nodeFetcher - Function(nodeId: string): Object\n */\n\n\nfunction expandNodeToViewHierarchy(targetNode, nodes, expandInfo, nodeFetcher) {\n  var newNodeList = [];\n  Constants.EXPAND_KEYS.forEach(function (expandKeyName) {\n    if (targetNode.hasOwnProperty(expandKeyName)) {\n      var nodeList = targetNode[expandKeyName];\n      nodeList.forEach(function (nodeId) {\n        var extraNode = nodeFetcher(nodeId);\n\n        if (extraNode) {\n          newNodeList.push(extraNode);\n\n          if (nodes.indexOf(extraNode) === -1) {\n            nodes.push(extraNode);\n          }\n        }\n      });\n    }\n  });\n  expandInfo[targetNode.id] = {\n    id: targetNode.id,\n    nodes: newNodeList\n  };\n  /**\n   * We want to include children group to parent hull, we check now\n   */\n\n  if (targetNode.hasOwnProperty('parentList')) {\n    for (var i = 0; i < targetNode['parentList'].length; i++) {\n      var parentId = targetNode['parentList'][i];\n\n      if (expandInfo.hasOwnProperty(parentId)) {\n        if (!expandInfo[parentId].hasOwnProperty('children')) {\n          expandInfo[parentId]['children'] = [];\n        }\n\n        if (expandInfo[parentId]['children'].indexOf(targetNode.id) === -1) {\n          expandInfo[parentId]['children'].push(targetNode.id);\n        }\n      }\n    }\n  }\n}\n/**\n * Shrink a node from view hierarchy\n *\n * @param {object} targetNode - node reference\n * @param {Array<object>} nodes - node list, would modify\n * @param {object} expandInfo - expand info\n * @param {Function} nodeFetcher - nodeFetcher(nodeId: string): Object\n */\n\n\nfunction shrinkNode(targetNode, nodes, expandInfo, nodeFetcher) {\n  // remove HOLD state\n  // back-up original space\n  var uiNode = nodeFetcher(targetNode.id, true);\n\n  if (uiNode.hasOwnProperty('__original_point_backup__')) {\n    uiNode.fx = uiNode['__original_point_backup__'].x;\n    uiNode.fy = uiNode['__original_point_backup__'].y;\n    uiNode.x = uiNode['__original_point_backup__'].x;\n    uiNode.y = uiNode['__original_point_backup__'].y;\n    uiNode.vx = 0;\n    uiNode.vy = 0;\n    delete uiNode['__original_point_backup__'];\n  }\n\n  setNodeAttribute(targetNode, 'expand', false);\n  shrinkNodeFromViewHierarchy(targetNode, nodes, nodeFetcher, expandInfo);\n}\n/**\n * This method will remove all possible nodes from the current view hierarchy\n *\n * @param {object} targetNode - node reference\n * @param {Array<object>} nodes - current node list\n * @param {Function} nodeFetcher - Function(nodeId: string): Object\n * @param {object} expandInfo - expand info\n * @returns {Array<object>} new node list array\n * @private\n */\n\n\nfunction shrinkNodeFromViewHierarchy(targetNode, nodes, nodeFetcher, expandInfo) {\n  var needToRemoveNodeList = []; // remove children\n\n  recursiveRemoveExpandedNode(targetNode.id, expandInfo, needToRemoveNodeList); // check if any node mark it as children\n\n  for (var keyName in expandInfo) {\n    if (expandInfo.hasOwnProperty(keyName)) {\n      if (expandInfo[keyName].hasOwnProperty('children')) {\n        expandInfo[keyName]['children'] = expandInfo[keyName]['children'].filter(function (d) {\n          return d !== targetNode.id;\n        });\n      }\n    }\n  }\n\n  delete expandInfo[targetNode.id];\n  /**\n   * IMPORTANT: Remove force layout parameters, it will stop the next expansion\n   */\n\n  needToRemoveNodeList.forEach(function (d) {\n    return cleanForceLayoutData(d);\n  });\n\n  for (var i = nodes.length - 1; i >= 0; i -= 1) {\n    var d = nodes[i];\n\n    if (needToRemoveNodeList.indexOf(d) !== -1) {\n      nodes.splice(i, 1);\n    }\n  }\n}\n/**\n * Remove all sub-children of current node\n *\n * @param {string} currentNodeId - node id\n * @param {object} expandInfo - expand info from Data Model\n * @param {Array<object>} needToRemoveNodeList - A list of unused nodes\n * @private\n */\n\n\nfunction recursiveRemoveExpandedNode(currentNodeId, expandInfo, needToRemoveNodeList) {\n  var currentNodeExpandInfo = expandInfo[currentNodeId];\n\n  if (currentNodeExpandInfo.hasOwnProperty('children')) {\n    currentNodeExpandInfo.children.forEach(function (childId) {\n      recursiveRemoveExpandedNode(childId, expandInfo, needToRemoveNodeList);\n    });\n  }\n\n  expandInfo[currentNodeId].nodes.forEach(function (d) {\n    needToRemoveNodeList.push(d);\n  });\n  delete expandInfo[currentNodeId];\n}\n/**\n * Restore the node back to its original keys, DELETE all d3.forceLayout keys\n *\n * @param {object} nodeWrapper - node reference\n * @private\n */\n\n\nfunction cleanForceLayoutData(nodeWrapper) {\n  for (var keyName in nodeWrapper) {\n    if (nodeWrapper.hasOwnProperty(keyName)) {\n      if (Constants.D3_GRAPHIC_KEYS.indexOf(keyName) !== -1) {\n        delete nodeWrapper[keyName];\n      }\n    }\n  }\n}\n/**\n * Restore state after space expansion\n *\n * @param {object} visibleNodes - All visible nodes on SVG\n */\n\n\nfunction endSpacePrepare(visibleNodes) {\n  for (var keyName in visibleNodes) {\n    if (visibleNodes.hasOwnProperty(keyName)) {\n      var d = visibleNodes[keyName];\n      setNodeAttribute(d, 'collisionRadius', Constants.DEFAULT_COLLISION_RADIUS);\n    }\n  }\n}\n/**\n * Start prepare space for expansion\n *\n * @param {object} nodeWrapper - node reference\n * @param {object} visibleNodes - All visible nodes on SVG\n */\n\n\nfunction startSpacePrepare(nodeWrapper, visibleNodes) {\n  // back-up original position\n  if (!nodeWrapper.hasOwnProperty('__original_point_backup__')) {\n    nodeWrapper['__original_point_backup__'] = {\n      x: nodeWrapper.x,\n      y: nodeWrapper.y\n    };\n  } // clean fixed position\n\n\n  nodeWrapper.fx = null;\n  nodeWrapper.fy = null;\n\n  for (var keyName in visibleNodes) {\n    if (visibleNodes.hasOwnProperty(keyName)) {\n      var d = visibleNodes[keyName];\n      setNodeAttribute(d, 'collisionRadius', linkLength(childrenCount(d)));\n    }\n  }\n}\n/**\n * Linear regression function to ESTIMATE required Link Length\n *\n * linear regression 75.1663 + 5.00259x\n *\n * General Safety Margin = 10\n *\n * @param {number} nodeCount\n * @param {boolean} forLink if for link, DO NOT * 1.5\n * @private\n */\n\n\nfunction linkLength(nodeCount) {\n  var forLink = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n  if (nodeCount <= 1) {\n    return 50;\n  } else {\n    return length = (5.00259 * nodeCount + 75.1663 + 10) * 0.7;\n  }\n}\n/**\n * Count the size of Children\n * If\n *\n * 1. expandInfo is provided\n *      - count active children\n * 2. expandInfo is missing\n *      - count potential children\n *\n * @param {object} node - node reference\n * @param {object=} expandInfo - expand info from Data Model\n * @returns {number} # of children\n * @private\n */\n\n\nfunction childrenCount(node) {\n  var expandInfo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var count = 1;\n\n  if (expandInfo) {\n    if (expandInfo[node.id]) {\n      // if it is expanded\n      count += expandInfo[node.id].nodes.length; // if it have children\n\n      if (expandInfo[node.id].hasOwnProperty('children')) {\n        for (var i = 0; i < expandInfo[node.id].children.length; i++) {\n          count += expandInfo[expandInfo[node.id].children[i]].nodes.length;\n        }\n      }\n    }\n  } else {\n    Constants.EXPAND_KEYS.forEach(function (expandKeyName) {\n      if (node.hasOwnProperty(expandKeyName)) {\n        count += node[expandKeyName].length;\n      }\n    });\n  }\n\n  return count;\n}\n\n//# sourceURL=webpack:///./src/main/webapp/visual/data-model/utils.js?");

/***/ }),

/***/ "./src/main/webapp/visual/data-model/version-control/version-control.js":
/*!******************************************************************************!*\
  !*** ./src/main/webapp/visual/data-model/version-control/version-control.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _keys = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/core-js/object/keys */ \"./node_modules/@babel/runtime/core-js/object/keys.js\"));\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\"));\n\nvar _lodash = _interopRequireDefault(__webpack_require__(/*! lodash */ \"./node_modules/lodash/lodash.js\"));\n\n/**\n * Version Control Manager for dynamic updating\n */\nvar VersionControl =\n/*#__PURE__*/\nfunction () {\n  function VersionControl() {\n    (0, _classCallCheck2.default)(this, VersionControl);\n    (0, _defineProperty2.default)(this, \"versionRecord\", {});\n    (0, _defineProperty2.default)(this, \"currentNodeStructure\", {});\n  }\n\n  (0, _createClass2.default)(VersionControl, [{\n    key: \"diff\",\n\n    /**\n     * Compare new data and old data, return CHANGED keys\n     *\n     * @param {object} newParsedResult - parsed server data\n     * @returns {{changed: boolean, remove: Array<string>}} List of CHANGED node REAL id\n     */\n    value: function diff(newParsedResult) {\n      var _this = this;\n\n      var changed = false;\n      var removedIdList = [];\n      (0, _keys.default)(newParsedResult.topLevel).forEach(function (topLevelId) {\n        var latestVersionRecord = newParsedResult.versionRecord[topLevelId];\n        var currentVersionRecord = _this.versionRecord[topLevelId];\n\n        if (!currentVersionRecord || latestVersionRecord.time > currentVersionRecord.time && latestVersionRecord.uuid !== currentVersionRecord.uuid) {\n          // mark changed\n          changed = true; // latest node ID list under `topLevelId`\n\n          var latestIdList = newParsedResult.topLevel[topLevelId]; // current node ID list under `topLevelId`\n\n          var currentIdList = _this.currentNodeStructure[topLevelId]; // diff 2 array get REMOVED NODE LIST\n\n          var diffArray = _lodash.default.difference(currentIdList, latestIdList);\n\n          diffArray.forEach(function (d) {\n            return removedIdList.push(d);\n          });\n        }\n\n        if (latestVersionRecord.time === -1 && _this.currentNodeStructure[topLevelId]) {\n          // If the node is being completely removed\n          _this.currentNodeStructure[topLevelId].forEach(function (d) {\n            return removedIdList.push(d);\n          });\n        }\n      });\n      return {\n        changed: changed,\n        remove: removedIdList\n      };\n    }\n    /**\n     * Save new node structure\n     *\n     * @param {object} newParsedResult - parsed server data\n     * @returns {{change: Array<string>, remove: Array<string>}} List of CHANGED node REAL id\n     */\n\n  }, {\n    key: \"updateVersion\",\n    value: function updateVersion(newParsedResult) {\n      _lodash.default.assign(this.currentNodeStructure, newParsedResult.topLevel);\n\n      _lodash.default.assign(this.versionRecord, newParsedResult.versionRecord);\n    }\n  }]);\n  return VersionControl;\n}();\n\nvar _default = VersionControl;\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/main/webapp/visual/data-model/version-control/version-control.js?");

/***/ })

}]);